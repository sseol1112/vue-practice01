{"ast":null,"code":"/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\"use strict\";\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nrequire(\"core-js/modules/es.regexp.flags.js\");\n\n(function () {\n  var MOZ_TO_ME = {\n    Program: function (M) {\n      return new AST_Toplevel({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        body: normalize_directives(M.body.map(from_moz))\n      });\n    },\n    ArrowFunctionExpression: function (M) {\n      var argnames = [],\n          rest = null;\n      M.params.forEach(function (param) {\n        if (param.type == \"RestElement\") {\n          rest = from_moz(param.argument);\n        } else {\n          argnames.push(from_moz(param));\n        }\n      });\n      var fn = new (M.async ? AST_AsyncArrow : AST_Arrow)({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        argnames: argnames,\n        rest: rest\n      });\n      var node = from_moz(M.body);\n\n      if (node instanceof AST_BlockStatement) {\n        fn.body = normalize_directives(node.body);\n        fn.value = null;\n      } else {\n        fn.body = [];\n        fn.value = node;\n      }\n\n      return fn;\n    },\n    FunctionDeclaration: function (M) {\n      var ctor;\n\n      if (M.async) {\n        ctor = M.generator ? AST_AsyncGeneratorDefun : AST_AsyncDefun;\n      } else {\n        ctor = M.generator ? AST_GeneratorDefun : AST_Defun;\n      }\n\n      var argnames = [],\n          rest = null;\n      M.params.forEach(function (param) {\n        if (param.type == \"RestElement\") {\n          rest = from_moz(param.argument);\n        } else {\n          argnames.push(from_moz(param));\n        }\n      });\n      return new ctor({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        name: from_moz(M.id),\n        argnames: argnames,\n        rest: rest,\n        body: normalize_directives(from_moz(M.body).body)\n      });\n    },\n    FunctionExpression: function (M) {\n      var ctor;\n\n      if (M.async) {\n        ctor = M.generator ? AST_AsyncGeneratorFunction : AST_AsyncFunction;\n      } else {\n        ctor = M.generator ? AST_GeneratorFunction : AST_Function;\n      }\n\n      var argnames = [],\n          rest = null;\n      M.params.forEach(function (param) {\n        if (param.type == \"RestElement\") {\n          rest = from_moz(param.argument);\n        } else {\n          argnames.push(from_moz(param));\n        }\n      });\n      return new ctor({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        name: from_moz(M.id),\n        argnames: argnames,\n        rest: rest,\n        body: normalize_directives(from_moz(M.body).body)\n      });\n    },\n    ClassDeclaration: function (M) {\n      return new AST_DefClass({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        name: from_moz(M.id),\n        extends: from_moz(M.superClass),\n        properties: M.body.body.map(from_moz)\n      });\n    },\n    ClassExpression: function (M) {\n      return new AST_ClassExpression({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        name: from_moz(M.id),\n        extends: from_moz(M.superClass),\n        properties: M.body.body.map(from_moz)\n      });\n    },\n    MethodDefinition: function (M) {\n      var key = M.key,\n          internal = false;\n\n      if (M.computed) {\n        key = from_moz(key);\n      } else if (key.type == \"PrivateIdentifier\") {\n        internal = true;\n        key = \"#\" + key.name;\n      } else {\n        key = read_name(key);\n      }\n\n      var ctor = AST_ClassMethod,\n          value = from_moz(M.value);\n\n      switch (M.kind) {\n        case \"get\":\n          ctor = AST_ClassGetter;\n          value = new AST_Accessor(value);\n          break;\n\n        case \"set\":\n          ctor = AST_ClassSetter;\n          value = new AST_Accessor(value);\n          break;\n      }\n\n      return new ctor({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        key: key,\n        private: internal,\n        static: M.static,\n        value: value\n      });\n    },\n    PropertyDefinition: function (M) {\n      var key = M.key,\n          internal = false;\n\n      if (M.computed) {\n        key = from_moz(key);\n      } else if (key.type == \"PrivateIdentifier\") {\n        internal = true;\n        key = \"#\" + key.name;\n      } else {\n        key = read_name(key);\n      }\n\n      return new AST_ClassField({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        key: key,\n        private: internal,\n        static: M.static,\n        value: from_moz(M.value)\n      });\n    },\n    StaticBlock: function (M) {\n      var start = my_start_token(M);\n      var end = my_end_token(M);\n      return new AST_ClassInit({\n        start: start,\n        end: end,\n        value: new AST_ClassInitBlock({\n          start: start,\n          end: end,\n          body: normalize_directives(M.body.map(from_moz))\n        })\n      });\n    },\n    ForOfStatement: function (M) {\n      return new (M.await ? AST_ForAwaitOf : AST_ForOf)({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        init: from_moz(M.left),\n        object: from_moz(M.right),\n        body: from_moz(M.body)\n      });\n    },\n    TryStatement: function (M) {\n      var handlers = M.handlers || [M.handler];\n\n      if (handlers.length > 1 || M.guardedHandlers && M.guardedHandlers.length) {\n        throw new Error(\"Multiple catch clauses are not supported.\");\n      }\n\n      return new AST_Try({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        body: from_moz(M.block).body,\n        bcatch: from_moz(handlers[0]),\n        bfinally: M.finalizer ? new AST_Finally(from_moz(M.finalizer)) : null\n      });\n    },\n    Property: function (M) {\n      var key = M.computed ? from_moz(M.key) : read_name(M.key);\n      var args = {\n        start: my_start_token(M),\n        end: my_end_token(M),\n        key: key,\n        value: from_moz(M.value)\n      };\n      if (M.kind == \"init\") return new (M.method ? AST_ObjectMethod : AST_ObjectKeyVal)(args);\n      args.value = new AST_Accessor(args.value);\n      if (M.kind == \"get\") return new AST_ObjectGetter(args);\n      if (M.kind == \"set\") return new AST_ObjectSetter(args);\n    },\n    ArrayExpression: function (M) {\n      return new AST_Array({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        elements: M.elements.map(function (elem) {\n          return elem === null ? new AST_Hole() : from_moz(elem);\n        })\n      });\n    },\n    ArrayPattern: function (M) {\n      var elements = [],\n          rest = null;\n      M.elements.forEach(function (el) {\n        if (el === null) {\n          elements.push(new AST_Hole());\n        } else if (el.type == \"RestElement\") {\n          rest = from_moz(el.argument);\n        } else {\n          elements.push(from_moz(el));\n        }\n      });\n      return new AST_DestructuredArray({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        elements: elements,\n        rest: rest\n      });\n    },\n    ObjectPattern: function (M) {\n      var props = [],\n          rest = null;\n      M.properties.forEach(function (prop) {\n        if (prop.type == \"RestElement\") {\n          rest = from_moz(prop.argument);\n        } else {\n          props.push(new AST_DestructuredKeyVal(from_moz(prop)));\n        }\n      });\n      return new AST_DestructuredObject({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        properties: props,\n        rest: rest\n      });\n    },\n    MemberExpression: function (M) {\n      return new (M.computed ? AST_Sub : AST_Dot)({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        optional: M.optional,\n        expression: from_moz(M.object),\n        property: M.computed ? from_moz(M.property) : M.property.name\n      });\n    },\n    MetaProperty: function (M) {\n      var expr = from_moz(M.meta);\n      var prop = read_name(M.property);\n      if (expr.name == \"new\" && prop == \"target\") return new AST_NewTarget({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        name: \"new.target\"\n      });\n      return new AST_Dot({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        expression: expr,\n        property: prop\n      });\n    },\n    SwitchCase: function (M) {\n      return new (M.test ? AST_Case : AST_Default)({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        expression: from_moz(M.test),\n        body: M.consequent.map(from_moz)\n      });\n    },\n    ExportAllDeclaration: function (M) {\n      var start = my_start_token(M);\n      var end = my_end_token(M);\n      return new AST_ExportForeign({\n        start: start,\n        end: end,\n        aliases: [M.exported ? from_moz_alias(M.exported) : new AST_String({\n          start: start,\n          value: \"*\",\n          end: end\n        })],\n        keys: [new AST_String({\n          start: start,\n          value: \"*\",\n          end: end\n        })],\n        path: from_moz(M.source)\n      });\n    },\n    ExportDefaultDeclaration: function (M) {\n      var decl = from_moz(M.declaration);\n      if (!decl.name) switch (decl.CTOR) {\n        case AST_AsyncDefun:\n          decl = new AST_AsyncFunction(decl);\n          break;\n\n        case AST_AsyncGeneratorDefun:\n          decl = new AST_AsyncGeneratorFunction(decl);\n          break;\n\n        case AST_DefClass:\n          decl = new AST_ClassExpression(decl);\n          break;\n\n        case AST_Defun:\n          decl = new AST_Function(decl);\n          break;\n\n        case AST_GeneratorDefun:\n          decl = new AST_GeneratorFunction(decl);\n          break;\n      }\n      return new AST_ExportDefault({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        body: decl\n      });\n    },\n    ExportNamedDeclaration: function (M) {\n      if (M.declaration) return new AST_ExportDeclaration({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        body: from_moz(M.declaration)\n      });\n\n      if (M.source) {\n        var aliases = [],\n            keys = [];\n        M.specifiers.forEach(function (prop) {\n          aliases.push(from_moz_alias(prop.exported));\n          keys.push(from_moz_alias(prop.local));\n        });\n        return new AST_ExportForeign({\n          start: my_start_token(M),\n          end: my_end_token(M),\n          aliases: aliases,\n          keys: keys,\n          path: from_moz(M.source)\n        });\n      }\n\n      return new AST_ExportReferences({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        properties: M.specifiers.map(function (prop) {\n          var sym = new AST_SymbolExport(from_moz(prop.local));\n          sym.alias = from_moz_alias(prop.exported);\n          return sym;\n        })\n      });\n    },\n    ImportDeclaration: function (M) {\n      var start = my_start_token(M);\n      var end = my_end_token(M);\n      var all = null,\n          def = null,\n          props = null;\n      M.specifiers.forEach(function (prop) {\n        var sym = new AST_SymbolImport(from_moz(prop.local));\n\n        switch (prop.type) {\n          case \"ImportDefaultSpecifier\":\n            def = sym;\n            def.key = new AST_String({\n              start: start,\n              value: \"\",\n              end: end\n            });\n            break;\n\n          case \"ImportNamespaceSpecifier\":\n            all = sym;\n            all.key = new AST_String({\n              start: start,\n              value: \"*\",\n              end: end\n            });\n            break;\n\n          default:\n            sym.key = from_moz_alias(prop.imported);\n            if (!props) props = [];\n            props.push(sym);\n            break;\n        }\n      });\n      return new AST_Import({\n        start: start,\n        end: end,\n        all: all,\n        default: def,\n        properties: props,\n        path: from_moz(M.source)\n      });\n    },\n    ImportExpression: function (M) {\n      var start = my_start_token(M);\n      var arg = from_moz(M.source);\n      return new AST_Call({\n        start: start,\n        end: my_end_token(M),\n        expression: new AST_SymbolRef({\n          start: start,\n          end: arg.start,\n          name: \"import\"\n        }),\n        args: [arg]\n      });\n    },\n    VariableDeclaration: function (M) {\n      return new ({\n        const: AST_Const,\n        let: AST_Let\n      }[M.kind] || AST_Var)({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        definitions: M.declarations.map(from_moz)\n      });\n    },\n    Literal: function (M) {\n      var args = {\n        start: my_start_token(M),\n        end: my_end_token(M)\n      };\n\n      if (M.bigint) {\n        args.value = M.bigint.toLowerCase() + \"n\";\n        return new AST_BigInt(args);\n      }\n\n      var val = M.value;\n      if (val === null) return new AST_Null(args);\n      var rx = M.regex;\n\n      if (rx && rx.pattern) {\n        // RegExpLiteral as per ESTree AST spec\n        args.value = new RegExp(rx.pattern, rx.flags);\n        args.value.raw_source = rx.pattern;\n        return new AST_RegExp(args);\n      } else if (rx) {\n        // support legacy RegExp\n        args.value = M.regex && M.raw ? M.raw : val;\n        return new AST_RegExp(args);\n      }\n\n      switch (typeof val) {\n        case \"string\":\n          args.value = val;\n          return new AST_String(args);\n\n        case \"number\":\n          if (isNaN(val)) return new AST_NaN(args);\n          var negate, node;\n\n          if (isFinite(val)) {\n            negate = 1 / val < 0;\n            args.value = negate ? -val : val;\n            node = new AST_Number(args);\n          } else {\n            negate = val < 0;\n            node = new AST_Infinity(args);\n          }\n\n          return negate ? new AST_UnaryPrefix({\n            start: args.start,\n            end: args.end,\n            operator: \"-\",\n            expression: node\n          }) : node;\n\n        case \"boolean\":\n          return new (val ? AST_True : AST_False)(args);\n      }\n    },\n    TemplateLiteral: function (M) {\n      return new AST_Template({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        expressions: M.expressions.map(from_moz),\n        strings: M.quasis.map(function (el) {\n          return el.value.raw;\n        })\n      });\n    },\n    TaggedTemplateExpression: function (M) {\n      var tmpl = from_moz(M.quasi);\n      tmpl.start = my_start_token(M);\n      tmpl.end = my_end_token(M);\n      tmpl.tag = from_moz(M.tag);\n      return tmpl;\n    },\n    Identifier: function (M) {\n      var p,\n          level = FROM_MOZ_STACK.length - 1;\n\n      do {\n        p = FROM_MOZ_STACK[--level];\n      } while (p.type == \"ArrayPattern\" || p.type == \"AssignmentPattern\" && p.left === FROM_MOZ_STACK[level + 1] || p.type == \"ObjectPattern\" || p.type == \"Property\" && p.value === FROM_MOZ_STACK[level + 1] || p.type == \"VariableDeclarator\" && p.id === FROM_MOZ_STACK[level + 1]);\n\n      var ctor = AST_SymbolRef;\n\n      switch (p.type) {\n        case \"ArrowFunctionExpression\":\n          if (p.body !== FROM_MOZ_STACK[level + 1]) ctor = AST_SymbolFunarg;\n          break;\n\n        case \"BreakStatement\":\n        case \"ContinueStatement\":\n          ctor = AST_LabelRef;\n          break;\n\n        case \"CatchClause\":\n          ctor = AST_SymbolCatch;\n          break;\n\n        case \"ClassDeclaration\":\n          if (p.id === FROM_MOZ_STACK[level + 1]) ctor = AST_SymbolDefClass;\n          break;\n\n        case \"ClassExpression\":\n          if (p.id === FROM_MOZ_STACK[level + 1]) ctor = AST_SymbolClass;\n          break;\n\n        case \"FunctionDeclaration\":\n          ctor = p.id === FROM_MOZ_STACK[level + 1] ? AST_SymbolDefun : AST_SymbolFunarg;\n          break;\n\n        case \"FunctionExpression\":\n          ctor = p.id === FROM_MOZ_STACK[level + 1] ? AST_SymbolLambda : AST_SymbolFunarg;\n          break;\n\n        case \"LabeledStatement\":\n          ctor = AST_Label;\n          break;\n\n        case \"VariableDeclaration\":\n          ctor = {\n            const: AST_SymbolConst,\n            let: AST_SymbolLet\n          }[p.kind] || AST_SymbolVar;\n          break;\n      }\n\n      return new ctor({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        name: M.name\n      });\n    },\n    Super: function (M) {\n      return new AST_Super({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        name: \"super\"\n      });\n    },\n    ThisExpression: function (M) {\n      return new AST_This({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        name: \"this\"\n      });\n    },\n    ParenthesizedExpression: function (M) {\n      var node = from_moz(M.expression);\n      if (!node.start.parens) node.start.parens = [];\n      node.start.parens.push(my_start_token(M));\n      if (!node.end.parens) node.end.parens = [];\n      node.end.parens.push(my_end_token(M));\n      return node;\n    },\n    ChainExpression: function (M) {\n      var node = from_moz(M.expression);\n      node.terminal = true;\n      return node;\n    }\n  };\n\n  MOZ_TO_ME.UpdateExpression = MOZ_TO_ME.UnaryExpression = function To_Moz_Unary(M) {\n    var prefix = \"prefix\" in M ? M.prefix : M.type == \"UnaryExpression\" ? true : false;\n    return new (prefix ? AST_UnaryPrefix : AST_UnaryPostfix)({\n      start: my_start_token(M),\n      end: my_end_token(M),\n      operator: M.operator,\n      expression: from_moz(M.argument)\n    });\n  };\n\n  map(\"EmptyStatement\", AST_EmptyStatement);\n  map(\"ExpressionStatement\", AST_SimpleStatement, \"expression>body\");\n  map(\"BlockStatement\", AST_BlockStatement, \"body@body\");\n  map(\"IfStatement\", AST_If, \"test>condition, consequent>body, alternate>alternative\");\n  map(\"LabeledStatement\", AST_LabeledStatement, \"label>label, body>body\");\n  map(\"BreakStatement\", AST_Break, \"label>label\");\n  map(\"ContinueStatement\", AST_Continue, \"label>label\");\n  map(\"WithStatement\", AST_With, \"object>expression, body>body\");\n  map(\"SwitchStatement\", AST_Switch, \"discriminant>expression, cases@body\");\n  map(\"ReturnStatement\", AST_Return, \"argument>value\");\n  map(\"ThrowStatement\", AST_Throw, \"argument>value\");\n  map(\"WhileStatement\", AST_While, \"test>condition, body>body\");\n  map(\"DoWhileStatement\", AST_Do, \"test>condition, body>body\");\n  map(\"ForStatement\", AST_For, \"init>init, test>condition, update>step, body>body\");\n  map(\"ForInStatement\", AST_ForIn, \"left>init, right>object, body>body\");\n  map(\"DebuggerStatement\", AST_Debugger);\n  map(\"VariableDeclarator\", AST_VarDef, \"id>name, init>value\");\n  map(\"CatchClause\", AST_Catch, \"param>argname, body%body\");\n  map(\"BinaryExpression\", AST_Binary, \"operator=operator, left>left, right>right\");\n  map(\"LogicalExpression\", AST_Binary, \"operator=operator, left>left, right>right\");\n  map(\"AssignmentExpression\", AST_Assign, \"operator=operator, left>left, right>right\");\n  map(\"AssignmentPattern\", AST_DefaultValue, \"left>name, right>value\");\n  map(\"ConditionalExpression\", AST_Conditional, \"test>condition, consequent>consequent, alternate>alternative\");\n  map(\"NewExpression\", AST_New, \"callee>expression, arguments@args, pure=pure\");\n  map(\"CallExpression\", AST_Call, \"callee>expression, arguments@args, optional=optional, pure=pure\");\n  map(\"SequenceExpression\", AST_Sequence, \"expressions@expressions\");\n  map(\"SpreadElement\", AST_Spread, \"argument>expression\");\n  map(\"ObjectExpression\", AST_Object, \"properties@properties\");\n  map(\"AwaitExpression\", AST_Await, \"argument>expression\");\n  map(\"YieldExpression\", AST_Yield, \"argument>expression, delegate=nested\");\n  def_to_moz(AST_Toplevel, function To_Moz_Program(M) {\n    return to_moz_scope(\"Program\", M);\n  });\n  def_to_moz(AST_LambdaDefinition, function To_Moz_FunctionDeclaration(M) {\n    var params = M.argnames.map(to_moz);\n    if (M.rest) params.push({\n      type: \"RestElement\",\n      argument: to_moz(M.rest)\n    });\n    return {\n      type: \"FunctionDeclaration\",\n      id: to_moz(M.name),\n      async: is_async(M),\n      generator: is_generator(M),\n      params: params,\n      body: to_moz_scope(\"BlockStatement\", M)\n    };\n  });\n  def_to_moz(AST_Lambda, function To_Moz_FunctionExpression(M) {\n    var params = M.argnames.map(to_moz);\n    if (M.rest) params.push({\n      type: \"RestElement\",\n      argument: to_moz(M.rest)\n    });\n    if (is_arrow(M)) return {\n      type: \"ArrowFunctionExpression\",\n      async: is_async(M),\n      params: params,\n      body: M.value ? to_moz(M.value) : to_moz_scope(\"BlockStatement\", M)\n    };\n    return {\n      type: \"FunctionExpression\",\n      id: to_moz(M.name),\n      async: is_async(M),\n      generator: is_generator(M),\n      params: params,\n      body: to_moz_scope(\"BlockStatement\", M)\n    };\n  });\n  def_to_moz(AST_DefClass, function To_Moz_ClassDeclaration(M) {\n    return {\n      type: \"ClassDeclaration\",\n      id: to_moz(M.name),\n      superClass: to_moz(M.extends),\n      body: {\n        type: \"ClassBody\",\n        body: M.properties.map(to_moz)\n      }\n    };\n  });\n  def_to_moz(AST_ClassExpression, function To_Moz_ClassExpression(M) {\n    return {\n      type: \"ClassExpression\",\n      id: to_moz(M.name),\n      superClass: to_moz(M.extends),\n      body: {\n        type: \"ClassBody\",\n        body: M.properties.map(to_moz)\n      }\n    };\n  });\n\n  function To_Moz_MethodDefinition(kind) {\n    return function (M) {\n      var computed = M.key instanceof AST_Node;\n      var key = computed ? to_moz(M.key) : M.private ? {\n        type: \"PrivateIdentifier\",\n        name: M.key.slice(1)\n      } : {\n        type: \"Literal\",\n        value: M.key\n      };\n      return {\n        type: \"MethodDefinition\",\n        kind: kind,\n        computed: computed,\n        key: key,\n        static: M.static,\n        value: to_moz(M.value)\n      };\n    };\n  }\n\n  def_to_moz(AST_ClassGetter, To_Moz_MethodDefinition(\"get\"));\n  def_to_moz(AST_ClassSetter, To_Moz_MethodDefinition(\"set\"));\n  def_to_moz(AST_ClassMethod, To_Moz_MethodDefinition(\"method\"));\n  def_to_moz(AST_ClassField, function To_Moz_PropertyDefinition(M) {\n    var computed = M.key instanceof AST_Node;\n    var key = computed ? to_moz(M.key) : M.private ? {\n      type: \"PrivateIdentifier\",\n      name: M.key.slice(1)\n    } : {\n      type: \"Literal\",\n      value: M.key\n    };\n    return {\n      type: \"PropertyDefinition\",\n      computed: computed,\n      key: key,\n      static: M.static,\n      value: to_moz(M.value)\n    };\n  });\n  def_to_moz(AST_ClassInit, function To_Moz_StaticBlock(M) {\n    return to_moz_scope(\"StaticBlock\", M.value);\n  });\n\n  function To_Moz_ForOfStatement(is_await) {\n    return function (M) {\n      return {\n        type: \"ForOfStatement\",\n        await: is_await,\n        left: to_moz(M.init),\n        right: to_moz(M.object),\n        body: to_moz(M.body)\n      };\n    };\n  }\n\n  def_to_moz(AST_ForAwaitOf, To_Moz_ForOfStatement(true));\n  def_to_moz(AST_ForOf, To_Moz_ForOfStatement(false));\n  def_to_moz(AST_Directive, function To_Moz_Directive(M) {\n    return {\n      type: \"ExpressionStatement\",\n      expression: set_moz_loc(M, {\n        type: \"Literal\",\n        value: M.value\n      })\n    };\n  });\n  def_to_moz(AST_SwitchBranch, function To_Moz_SwitchCase(M) {\n    return {\n      type: \"SwitchCase\",\n      test: to_moz(M.expression),\n      consequent: M.body.map(to_moz)\n    };\n  });\n  def_to_moz(AST_Try, function To_Moz_TryStatement(M) {\n    return {\n      type: \"TryStatement\",\n      block: to_moz_block(M),\n      handler: to_moz(M.bcatch),\n      guardedHandlers: [],\n      finalizer: to_moz(M.bfinally)\n    };\n  });\n  def_to_moz(AST_Catch, function To_Moz_CatchClause(M) {\n    return {\n      type: \"CatchClause\",\n      param: to_moz(M.argname),\n      guard: null,\n      body: to_moz_block(M)\n    };\n  });\n  def_to_moz(AST_ExportDeclaration, function To_Moz_ExportNamedDeclaration_declaration(M) {\n    return {\n      type: \"ExportNamedDeclaration\",\n      declaration: to_moz(M.body)\n    };\n  });\n  def_to_moz(AST_ExportDefault, function To_Moz_ExportDefaultDeclaration(M) {\n    return {\n      type: \"ExportDefaultDeclaration\",\n      declaration: to_moz(M.body)\n    };\n  });\n  def_to_moz(AST_ExportForeign, function To_Moz_ExportAllDeclaration_ExportNamedDeclaration(M) {\n    if (M.keys[0].value == \"*\") return {\n      type: \"ExportAllDeclaration\",\n      exported: M.aliases[0].value == \"*\" ? null : to_moz_alias(M.aliases[0]),\n      source: to_moz(M.path)\n    };\n    var specifiers = [];\n\n    for (var i = 0; i < M.aliases.length; i++) {\n      specifiers.push(set_moz_loc({\n        start: M.keys[i].start,\n        end: M.aliases[i].end\n      }, {\n        type: \"ExportSpecifier\",\n        local: to_moz_alias(M.keys[i]),\n        exported: to_moz_alias(M.aliases[i])\n      }));\n    }\n\n    return {\n      type: \"ExportNamedDeclaration\",\n      specifiers: specifiers,\n      source: to_moz(M.path)\n    };\n  });\n  def_to_moz(AST_ExportReferences, function To_Moz_ExportNamedDeclaration_specifiers(M) {\n    return {\n      type: \"ExportNamedDeclaration\",\n      specifiers: M.properties.map(function (prop) {\n        return set_moz_loc({\n          start: prop.start,\n          end: prop.alias.end\n        }, {\n          type: \"ExportSpecifier\",\n          local: to_moz(prop),\n          exported: to_moz_alias(prop.alias)\n        });\n      })\n    };\n  });\n  def_to_moz(AST_Import, function To_Moz_ImportDeclaration(M) {\n    var specifiers = M.properties ? M.properties.map(function (prop) {\n      return set_moz_loc({\n        start: prop.key.start,\n        end: prop.end\n      }, {\n        type: \"ImportSpecifier\",\n        local: to_moz(prop),\n        imported: to_moz_alias(prop.key)\n      });\n    }) : [];\n    if (M.all) specifiers.unshift(set_moz_loc(M.all, {\n      type: \"ImportNamespaceSpecifier\",\n      local: to_moz(M.all)\n    }));\n    if (M.default) specifiers.unshift(set_moz_loc(M.default, {\n      type: \"ImportDefaultSpecifier\",\n      local: to_moz(M.default)\n    }));\n    return {\n      type: \"ImportDeclaration\",\n      specifiers: specifiers,\n      source: to_moz(M.path)\n    };\n  });\n  def_to_moz(AST_Definitions, function To_Moz_VariableDeclaration(M) {\n    return {\n      type: \"VariableDeclaration\",\n      kind: M.TYPE.toLowerCase(),\n      declarations: M.definitions.map(to_moz)\n    };\n  });\n  def_to_moz(AST_PropAccess, function To_Moz_MemberExpression(M) {\n    var computed = M instanceof AST_Sub;\n    var expr = {\n      type: \"MemberExpression\",\n      object: to_moz(M.expression),\n      computed: computed,\n      optional: M.optional,\n      property: computed ? to_moz(M.property) : {\n        type: \"Identifier\",\n        name: M.property\n      }\n    };\n    return M.terminal ? {\n      type: \"ChainExpression\",\n      expression: expr\n    } : expr;\n  });\n  def_to_moz(AST_Unary, function To_Moz_Unary(M) {\n    return {\n      type: M.operator == \"++\" || M.operator == \"--\" ? \"UpdateExpression\" : \"UnaryExpression\",\n      operator: M.operator,\n      prefix: M instanceof AST_UnaryPrefix,\n      argument: to_moz(M.expression)\n    };\n  });\n  def_to_moz(AST_Binary, function To_Moz_BinaryExpression(M) {\n    return {\n      type: M.operator == \"&&\" || M.operator == \"||\" ? \"LogicalExpression\" : \"BinaryExpression\",\n      left: to_moz(M.left),\n      operator: M.operator,\n      right: to_moz(M.right)\n    };\n  });\n  def_to_moz(AST_Array, function To_Moz_ArrayExpression(M) {\n    return {\n      type: \"ArrayExpression\",\n      elements: M.elements.map(to_moz)\n    };\n  });\n  def_to_moz(AST_DestructuredArray, function To_Moz_ArrayPattern(M) {\n    var elements = M.elements.map(to_moz);\n    if (M.rest) elements.push({\n      type: \"RestElement\",\n      argument: to_moz(M.rest)\n    });\n    return {\n      type: \"ArrayPattern\",\n      elements: elements\n    };\n  });\n  def_to_moz(AST_DestructuredKeyVal, function To_Moz_Property(M) {\n    var computed = M.key instanceof AST_Node;\n    var key = computed ? to_moz(M.key) : {\n      type: \"Literal\",\n      value: M.key\n    };\n    return {\n      type: \"Property\",\n      kind: \"init\",\n      computed: computed,\n      key: key,\n      value: to_moz(M.value)\n    };\n  });\n  def_to_moz(AST_DestructuredObject, function To_Moz_ObjectPattern(M) {\n    var props = M.properties.map(to_moz);\n    if (M.rest) props.push({\n      type: \"RestElement\",\n      argument: to_moz(M.rest)\n    });\n    return {\n      type: \"ObjectPattern\",\n      properties: props\n    };\n  });\n  def_to_moz(AST_ObjectProperty, function To_Moz_Property(M) {\n    var computed = M.key instanceof AST_Node;\n    var key = computed ? to_moz(M.key) : {\n      type: \"Literal\",\n      value: M.key\n    };\n    var kind;\n\n    if (M instanceof AST_ObjectKeyVal) {\n      kind = \"init\";\n    } else if (M instanceof AST_ObjectGetter) {\n      kind = \"get\";\n    } else if (M instanceof AST_ObjectSetter) {\n      kind = \"set\";\n    }\n\n    return {\n      type: \"Property\",\n      kind: kind,\n      computed: computed,\n      method: M instanceof AST_ObjectMethod,\n      key: key,\n      value: to_moz(M.value)\n    };\n  });\n  def_to_moz(AST_Symbol, function To_Moz_Identifier(M) {\n    var def = M.definition();\n    return {\n      type: \"Identifier\",\n      name: def && def.mangled_name || M.name\n    };\n  });\n  def_to_moz(AST_Super, function To_Moz_Super() {\n    return {\n      type: \"Super\"\n    };\n  });\n  def_to_moz(AST_This, function To_Moz_ThisExpression() {\n    return {\n      type: \"ThisExpression\"\n    };\n  });\n  def_to_moz(AST_NewTarget, function To_Moz_MetaProperty() {\n    return {\n      type: \"MetaProperty\",\n      meta: {\n        type: \"Identifier\",\n        name: \"new\"\n      },\n      property: {\n        type: \"Identifier\",\n        name: \"target\"\n      }\n    };\n  });\n  def_to_moz(AST_RegExp, function To_Moz_RegExpLiteral(M) {\n    var flags = M.value.toString().match(/\\/([gimuy]*)$/)[1];\n    var value = \"/\" + M.value.raw_source + \"/\" + flags;\n    return {\n      type: \"Literal\",\n      value: value,\n      raw: value,\n      regex: {\n        pattern: M.value.raw_source,\n        flags: flags\n      }\n    };\n  });\n  def_to_moz(AST_BigInt, function To_Moz_BigInt(M) {\n    var value = M.value;\n    return {\n      type: \"Literal\",\n      bigint: value.slice(0, -1),\n      raw: value\n    };\n  });\n\n  function To_Moz_Literal(M) {\n    var value = M.value;\n\n    if (typeof value === \"number\" && (value < 0 || value === 0 && 1 / value < 0)) {\n      return {\n        type: \"UnaryExpression\",\n        operator: \"-\",\n        prefix: true,\n        argument: {\n          type: \"Literal\",\n          value: -value,\n          raw: M.start.raw\n        }\n      };\n    }\n\n    return {\n      type: \"Literal\",\n      value: value,\n      raw: M.start.raw\n    };\n  }\n\n  def_to_moz(AST_Boolean, To_Moz_Literal);\n  def_to_moz(AST_Constant, To_Moz_Literal);\n  def_to_moz(AST_Null, To_Moz_Literal);\n  def_to_moz(AST_Atom, function To_Moz_Atom(M) {\n    return {\n      type: \"Identifier\",\n      name: String(M.value)\n    };\n  });\n  def_to_moz(AST_Template, function To_Moz_TemplateLiteral_TaggedTemplateExpression(M) {\n    var last = M.strings.length - 1;\n    var tmpl = {\n      type: \"TemplateLiteral\",\n      expressions: M.expressions.map(to_moz),\n      quasis: M.strings.map(function (str, index) {\n        return {\n          type: \"TemplateElement\",\n          tail: index == last,\n          value: {\n            raw: str\n          }\n        };\n      })\n    };\n    if (!M.tag) return tmpl;\n    return {\n      type: \"TaggedTemplateExpression\",\n      tag: to_moz(M.tag),\n      quasi: tmpl\n    };\n  });\n  AST_Block.DEFMETHOD(\"to_mozilla_ast\", AST_BlockStatement.prototype.to_mozilla_ast);\n  AST_Hole.DEFMETHOD(\"to_mozilla_ast\", return_null);\n  AST_Node.DEFMETHOD(\"to_mozilla_ast\", function () {\n    throw new Error(\"Cannot convert AST_\" + this.TYPE);\n  });\n  /* -----[ tools ]----- */\n\n  function normalize_directives(body) {\n    for (var i = 0; i < body.length; i++) {\n      var stat = body[i];\n      if (!(stat instanceof AST_SimpleStatement)) break;\n      var node = stat.body;\n      if (!(node instanceof AST_String)) break;\n      if (stat.start.pos !== node.start.pos) break;\n      body[i] = new AST_Directive(node);\n    }\n\n    return body;\n  }\n\n  function raw_token(moznode) {\n    if (moznode.type == \"Literal\") {\n      return moznode.raw != null ? moznode.raw : moznode.value + \"\";\n    }\n  }\n\n  function my_start_token(moznode) {\n    var loc = moznode.loc,\n        start = loc && loc.start;\n    var range = moznode.range;\n    return new AST_Token({\n      file: loc && loc.source,\n      line: start && start.line,\n      col: start && start.column,\n      pos: range ? range[0] : moznode.start,\n      endline: start && start.line,\n      endcol: start && start.column,\n      endpos: range ? range[0] : moznode.start,\n      raw: raw_token(moznode)\n    });\n  }\n\n  function my_end_token(moznode) {\n    var loc = moznode.loc,\n        end = loc && loc.end;\n    var range = moznode.range;\n    return new AST_Token({\n      file: loc && loc.source,\n      line: end && end.line,\n      col: end && end.column,\n      pos: range ? range[1] : moznode.end,\n      endline: end && end.line,\n      endcol: end && end.column,\n      endpos: range ? range[1] : moznode.end,\n      raw: raw_token(moznode)\n    });\n  }\n\n  function read_name(M) {\n    return \"\" + M[M.type == \"Identifier\" ? \"name\" : \"value\"];\n  }\n\n  function map(moztype, mytype, propmap) {\n    var moz_to_me = [\"start: my_start_token(M)\", \"end: my_end_token(M)\"];\n    var me_to_moz = [\"type: \" + JSON.stringify(moztype)];\n    if (propmap) propmap.split(/\\s*,\\s*/).forEach(function (prop) {\n      var m = /([a-z0-9$_]+)(=|@|>|%)([a-z0-9$_]+)/i.exec(prop);\n      if (!m) throw new Error(\"Can't understand property map: \" + prop);\n      var moz = m[1],\n          how = m[2],\n          my = m[3];\n\n      switch (how) {\n        case \"@\":\n          moz_to_me.push(my + \": M.\" + moz + \".map(from_moz)\");\n          me_to_moz.push(moz + \": M.\" + my + \".map(to_moz)\");\n          break;\n\n        case \">\":\n          moz_to_me.push(my + \": from_moz(M.\" + moz + \")\");\n          me_to_moz.push(moz + \": to_moz(M.\" + my + \")\");\n          break;\n\n        case \"=\":\n          moz_to_me.push(my + \": M.\" + moz);\n          me_to_moz.push(moz + \": M.\" + my);\n          break;\n\n        case \"%\":\n          moz_to_me.push(my + \": from_moz(M.\" + moz + \").body\");\n          me_to_moz.push(moz + \": to_moz_block(M)\");\n          break;\n\n        default:\n          throw new Error(\"Can't understand operator in propmap: \" + prop);\n      }\n    });\n    MOZ_TO_ME[moztype] = new Function(\"U2\", \"my_start_token\", \"my_end_token\", \"from_moz\", [\"return function From_Moz_\" + moztype + \"(M) {\", \"    return new U2.AST_\" + mytype.TYPE + \"({\", moz_to_me.join(\",\\n\"), \"    });\", \"};\"].join(\"\\n\"))(exports, my_start_token, my_end_token, from_moz);\n    def_to_moz(mytype, new Function(\"to_moz\", \"to_moz_block\", \"to_moz_scope\", [\"return function To_Moz_\" + moztype + \"(M) {\", \"    return {\", me_to_moz.join(\",\\n\"), \"    };\", \"};\"].join(\"\\n\"))(to_moz, to_moz_block, to_moz_scope));\n  }\n\n  var FROM_MOZ_STACK = null;\n\n  function from_moz(moz) {\n    FROM_MOZ_STACK.push(moz);\n    var node = null;\n\n    if (moz) {\n      if (!HOP(MOZ_TO_ME, moz.type)) throw new Error(\"Unsupported type: \" + moz.type);\n      node = MOZ_TO_ME[moz.type](moz);\n    }\n\n    FROM_MOZ_STACK.pop();\n    return node;\n  }\n\n  function from_moz_alias(moz) {\n    return new AST_String({\n      start: my_start_token(moz),\n      value: read_name(moz),\n      end: my_end_token(moz)\n    });\n  }\n\n  AST_Node.from_mozilla_ast = function (node) {\n    var save_stack = FROM_MOZ_STACK;\n    FROM_MOZ_STACK = [];\n    var ast = from_moz(node);\n    FROM_MOZ_STACK = save_stack;\n    ast.walk(new TreeWalker(function (node) {\n      if (node instanceof AST_LabelRef) {\n        for (var level = 0, parent; parent = this.parent(level); level++) {\n          if (parent instanceof AST_Scope) break;\n\n          if (parent instanceof AST_LabeledStatement && parent.label.name == node.name) {\n            node.thedef = parent.label;\n            break;\n          }\n        }\n\n        if (!node.thedef) {\n          var s = node.start;\n          js_error(\"Undefined label \" + node.name, s.file, s.line, s.col, s.pos);\n        }\n      }\n    }));\n    return ast;\n  };\n\n  function set_moz_loc(mynode, moznode) {\n    var start = mynode.start;\n    var end = mynode.end;\n\n    if (start.pos != null && end.endpos != null) {\n      moznode.range = [start.pos, end.endpos];\n    }\n\n    if (start.line) {\n      moznode.loc = {\n        start: {\n          line: start.line,\n          column: start.col\n        },\n        end: end.endline ? {\n          line: end.endline,\n          column: end.endcol\n        } : null\n      };\n\n      if (start.file) {\n        moznode.loc.source = start.file;\n      }\n    }\n\n    return moznode;\n  }\n\n  function def_to_moz(mytype, handler) {\n    mytype.DEFMETHOD(\"to_mozilla_ast\", function () {\n      return set_moz_loc(this, handler(this));\n    });\n  }\n\n  function to_moz(node) {\n    return node != null ? node.to_mozilla_ast() : null;\n  }\n\n  function to_moz_alias(alias) {\n    return is_identifier_string(alias.value) ? set_moz_loc(alias, {\n      type: \"Identifier\",\n      name: alias.value\n    }) : to_moz(alias);\n  }\n\n  function to_moz_block(node) {\n    return {\n      type: \"BlockStatement\",\n      body: node.body.map(to_moz)\n    };\n  }\n\n  function to_moz_scope(type, node) {\n    var body = node.body.map(to_moz);\n\n    if (node.body[0] instanceof AST_SimpleStatement && node.body[0].body instanceof AST_String) {\n      body.unshift(to_moz(new AST_EmptyStatement(node.body[0])));\n    }\n\n    return {\n      type: type,\n      body: body\n    };\n  }\n})();","map":{"version":3,"names":["MOZ_TO_ME","Program","M","AST_Toplevel","start","my_start_token","end","my_end_token","body","normalize_directives","map","from_moz","ArrowFunctionExpression","argnames","rest","params","forEach","param","type","argument","push","fn","async","AST_AsyncArrow","AST_Arrow","node","AST_BlockStatement","value","FunctionDeclaration","ctor","generator","AST_AsyncGeneratorDefun","AST_AsyncDefun","AST_GeneratorDefun","AST_Defun","name","id","FunctionExpression","AST_AsyncGeneratorFunction","AST_AsyncFunction","AST_GeneratorFunction","AST_Function","ClassDeclaration","AST_DefClass","extends","superClass","properties","ClassExpression","AST_ClassExpression","MethodDefinition","key","internal","computed","read_name","AST_ClassMethod","kind","AST_ClassGetter","AST_Accessor","AST_ClassSetter","private","static","PropertyDefinition","AST_ClassField","StaticBlock","AST_ClassInit","AST_ClassInitBlock","ForOfStatement","await","AST_ForAwaitOf","AST_ForOf","init","left","object","right","TryStatement","handlers","handler","length","guardedHandlers","Error","AST_Try","block","bcatch","bfinally","finalizer","AST_Finally","Property","args","method","AST_ObjectMethod","AST_ObjectKeyVal","AST_ObjectGetter","AST_ObjectSetter","ArrayExpression","AST_Array","elements","elem","AST_Hole","ArrayPattern","el","AST_DestructuredArray","ObjectPattern","props","prop","AST_DestructuredKeyVal","AST_DestructuredObject","MemberExpression","AST_Sub","AST_Dot","optional","expression","property","MetaProperty","expr","meta","AST_NewTarget","SwitchCase","test","AST_Case","AST_Default","consequent","ExportAllDeclaration","AST_ExportForeign","aliases","exported","from_moz_alias","AST_String","keys","path","source","ExportDefaultDeclaration","decl","declaration","CTOR","AST_ExportDefault","ExportNamedDeclaration","AST_ExportDeclaration","specifiers","local","AST_ExportReferences","sym","AST_SymbolExport","alias","ImportDeclaration","all","def","AST_SymbolImport","imported","AST_Import","default","ImportExpression","arg","AST_Call","AST_SymbolRef","VariableDeclaration","const","AST_Const","let","AST_Let","AST_Var","definitions","declarations","Literal","bigint","toLowerCase","AST_BigInt","val","AST_Null","rx","regex","pattern","RegExp","flags","raw_source","AST_RegExp","raw","isNaN","AST_NaN","negate","isFinite","AST_Number","AST_Infinity","AST_UnaryPrefix","operator","AST_True","AST_False","TemplateLiteral","AST_Template","expressions","strings","quasis","TaggedTemplateExpression","tmpl","quasi","tag","Identifier","p","level","FROM_MOZ_STACK","AST_SymbolFunarg","AST_LabelRef","AST_SymbolCatch","AST_SymbolDefClass","AST_SymbolClass","AST_SymbolDefun","AST_SymbolLambda","AST_Label","AST_SymbolConst","AST_SymbolLet","AST_SymbolVar","Super","AST_Super","ThisExpression","AST_This","ParenthesizedExpression","parens","ChainExpression","terminal","UpdateExpression","UnaryExpression","To_Moz_Unary","prefix","AST_UnaryPostfix","AST_EmptyStatement","AST_SimpleStatement","AST_If","AST_LabeledStatement","AST_Break","AST_Continue","AST_With","AST_Switch","AST_Return","AST_Throw","AST_While","AST_Do","AST_For","AST_ForIn","AST_Debugger","AST_VarDef","AST_Catch","AST_Binary","AST_Assign","AST_DefaultValue","AST_Conditional","AST_New","AST_Sequence","AST_Spread","AST_Object","AST_Await","AST_Yield","def_to_moz","To_Moz_Program","to_moz_scope","AST_LambdaDefinition","To_Moz_FunctionDeclaration","to_moz","is_async","is_generator","AST_Lambda","To_Moz_FunctionExpression","is_arrow","To_Moz_ClassDeclaration","To_Moz_ClassExpression","To_Moz_MethodDefinition","AST_Node","slice","To_Moz_PropertyDefinition","To_Moz_StaticBlock","To_Moz_ForOfStatement","is_await","AST_Directive","To_Moz_Directive","set_moz_loc","AST_SwitchBranch","To_Moz_SwitchCase","To_Moz_TryStatement","to_moz_block","To_Moz_CatchClause","argname","guard","To_Moz_ExportNamedDeclaration_declaration","To_Moz_ExportDefaultDeclaration","To_Moz_ExportAllDeclaration_ExportNamedDeclaration","to_moz_alias","i","To_Moz_ExportNamedDeclaration_specifiers","To_Moz_ImportDeclaration","unshift","AST_Definitions","To_Moz_VariableDeclaration","TYPE","AST_PropAccess","To_Moz_MemberExpression","AST_Unary","To_Moz_BinaryExpression","To_Moz_ArrayExpression","To_Moz_ArrayPattern","To_Moz_Property","To_Moz_ObjectPattern","AST_ObjectProperty","AST_Symbol","To_Moz_Identifier","definition","mangled_name","To_Moz_Super","To_Moz_ThisExpression","To_Moz_MetaProperty","To_Moz_RegExpLiteral","toString","match","To_Moz_BigInt","To_Moz_Literal","AST_Boolean","AST_Constant","AST_Atom","To_Moz_Atom","String","To_Moz_TemplateLiteral_TaggedTemplateExpression","last","str","index","tail","AST_Block","DEFMETHOD","prototype","to_mozilla_ast","return_null","stat","pos","raw_token","moznode","loc","range","AST_Token","file","line","col","column","endline","endcol","endpos","moztype","mytype","propmap","moz_to_me","me_to_moz","JSON","stringify","split","m","exec","moz","how","my","Function","join","exports","HOP","pop","from_mozilla_ast","save_stack","ast","walk","TreeWalker","parent","AST_Scope","label","thedef","s","js_error","mynode","is_identifier_string"],"sources":["C:/dev/vue/node_modules/uglify-js/lib/mozilla-ast.js"],"sourcesContent":["/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\n\"use strict\";\n\n(function() {\n    var MOZ_TO_ME = {\n        Program: function(M) {\n            return new AST_Toplevel({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                body: normalize_directives(M.body.map(from_moz)),\n            });\n        },\n        ArrowFunctionExpression: function(M) {\n            var argnames = [], rest = null;\n            M.params.forEach(function(param) {\n                if (param.type == \"RestElement\") {\n                    rest = from_moz(param.argument);\n                } else {\n                    argnames.push(from_moz(param));\n                }\n            });\n            var fn = new (M.async ? AST_AsyncArrow : AST_Arrow)({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                argnames: argnames,\n                rest: rest,\n            });\n            var node = from_moz(M.body);\n            if (node instanceof AST_BlockStatement) {\n                fn.body = normalize_directives(node.body);\n                fn.value = null;\n            } else {\n                fn.body = [];\n                fn.value = node;\n            }\n            return fn;\n        },\n        FunctionDeclaration: function(M) {\n            var ctor;\n            if (M.async) {\n                ctor = M.generator ? AST_AsyncGeneratorDefun : AST_AsyncDefun;\n            } else {\n                ctor = M.generator ? AST_GeneratorDefun : AST_Defun;\n            }\n            var argnames = [], rest = null;\n            M.params.forEach(function(param) {\n                if (param.type == \"RestElement\") {\n                    rest = from_moz(param.argument);\n                } else {\n                    argnames.push(from_moz(param));\n                }\n            });\n            return new ctor({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                name: from_moz(M.id),\n                argnames: argnames,\n                rest: rest,\n                body: normalize_directives(from_moz(M.body).body),\n            });\n        },\n        FunctionExpression: function(M) {\n            var ctor;\n            if (M.async) {\n                ctor = M.generator ? AST_AsyncGeneratorFunction : AST_AsyncFunction;\n            } else {\n                ctor = M.generator ? AST_GeneratorFunction : AST_Function;\n            }\n            var argnames = [], rest = null;\n            M.params.forEach(function(param) {\n                if (param.type == \"RestElement\") {\n                    rest = from_moz(param.argument);\n                } else {\n                    argnames.push(from_moz(param));\n                }\n            });\n            return new ctor({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                name: from_moz(M.id),\n                argnames: argnames,\n                rest: rest,\n                body: normalize_directives(from_moz(M.body).body),\n            });\n        },\n        ClassDeclaration: function(M) {\n            return new AST_DefClass({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                name: from_moz(M.id),\n                extends: from_moz(M.superClass),\n                properties: M.body.body.map(from_moz),\n            });\n        },\n        ClassExpression: function(M) {\n            return new AST_ClassExpression({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                name: from_moz(M.id),\n                extends: from_moz(M.superClass),\n                properties: M.body.body.map(from_moz),\n            });\n        },\n        MethodDefinition: function(M) {\n            var key = M.key, internal = false;\n            if (M.computed) {\n                key = from_moz(key);\n            } else if (key.type == \"PrivateIdentifier\") {\n                internal = true;\n                key = \"#\" + key.name;\n            } else {\n                key = read_name(key);\n            }\n            var ctor = AST_ClassMethod, value = from_moz(M.value);\n            switch (M.kind) {\n              case \"get\":\n                ctor = AST_ClassGetter;\n                value = new AST_Accessor(value);\n                break;\n              case \"set\":\n                ctor = AST_ClassSetter;\n                value = new AST_Accessor(value);\n                break;\n            }\n            return new ctor({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                key: key,\n                private: internal,\n                static: M.static,\n                value: value,\n            });\n        },\n        PropertyDefinition: function(M) {\n            var key = M.key, internal = false;\n            if (M.computed) {\n                key = from_moz(key);\n            } else if (key.type == \"PrivateIdentifier\") {\n                internal = true;\n                key = \"#\" + key.name;\n            } else {\n                key = read_name(key);\n            }\n            return new AST_ClassField({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                key: key,\n                private: internal,\n                static: M.static,\n                value: from_moz(M.value),\n            });\n        },\n        StaticBlock: function(M) {\n            var start = my_start_token(M);\n            var end = my_end_token(M);\n            return new AST_ClassInit({\n                start: start,\n                end: end,\n                value: new AST_ClassInitBlock({\n                    start: start,\n                    end: end,\n                    body: normalize_directives(M.body.map(from_moz)),\n                }),\n            });\n        },\n        ForOfStatement: function(M) {\n            return new (M.await ? AST_ForAwaitOf : AST_ForOf)({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                init: from_moz(M.left),\n                object: from_moz(M.right),\n                body: from_moz(M.body),\n            });\n        },\n        TryStatement: function(M) {\n            var handlers = M.handlers || [M.handler];\n            if (handlers.length > 1 || M.guardedHandlers && M.guardedHandlers.length) {\n                throw new Error(\"Multiple catch clauses are not supported.\");\n            }\n            return new AST_Try({\n                start    : my_start_token(M),\n                end      : my_end_token(M),\n                body     : from_moz(M.block).body,\n                bcatch   : from_moz(handlers[0]),\n                bfinally : M.finalizer ? new AST_Finally(from_moz(M.finalizer)) : null,\n            });\n        },\n        Property: function(M) {\n            var key = M.computed ? from_moz(M.key) : read_name(M.key);\n            var args = {\n                start: my_start_token(M),\n                end: my_end_token(M),\n                key: key,\n                value: from_moz(M.value),\n            };\n            if (M.kind == \"init\") return new (M.method ? AST_ObjectMethod : AST_ObjectKeyVal)(args);\n            args.value = new AST_Accessor(args.value);\n            if (M.kind == \"get\") return new AST_ObjectGetter(args);\n            if (M.kind == \"set\") return new AST_ObjectSetter(args);\n        },\n        ArrayExpression: function(M) {\n            return new AST_Array({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                elements: M.elements.map(function(elem) {\n                    return elem === null ? new AST_Hole() : from_moz(elem);\n                }),\n            });\n        },\n        ArrayPattern: function(M) {\n            var elements = [], rest = null;\n            M.elements.forEach(function(el) {\n                if (el === null) {\n                    elements.push(new AST_Hole());\n                } else if (el.type == \"RestElement\") {\n                    rest = from_moz(el.argument);\n                } else {\n                    elements.push(from_moz(el));\n                }\n            });\n            return new AST_DestructuredArray({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                elements: elements,\n                rest: rest,\n            });\n        },\n        ObjectPattern: function(M) {\n            var props = [], rest = null;\n            M.properties.forEach(function(prop) {\n                if (prop.type == \"RestElement\") {\n                    rest = from_moz(prop.argument);\n                } else {\n                    props.push(new AST_DestructuredKeyVal(from_moz(prop)));\n                }\n            });\n            return new AST_DestructuredObject({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                properties: props,\n                rest: rest,\n            });\n        },\n        MemberExpression: function(M) {\n            return new (M.computed ? AST_Sub : AST_Dot)({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                optional: M.optional,\n                expression: from_moz(M.object),\n                property: M.computed ? from_moz(M.property) : M.property.name,\n            });\n        },\n        MetaProperty: function(M) {\n            var expr = from_moz(M.meta);\n            var prop = read_name(M.property);\n            if (expr.name == \"new\" && prop == \"target\") return new AST_NewTarget({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                name: \"new.target\",\n            });\n            return new AST_Dot({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                expression: expr,\n                property: prop,\n            });\n        },\n        SwitchCase: function(M) {\n            return new (M.test ? AST_Case : AST_Default)({\n                start      : my_start_token(M),\n                end        : my_end_token(M),\n                expression : from_moz(M.test),\n                body       : M.consequent.map(from_moz),\n            });\n        },\n        ExportAllDeclaration: function(M) {\n            var start = my_start_token(M);\n            var end = my_end_token(M);\n            return new AST_ExportForeign({\n                start: start,\n                end: end,\n                aliases: [ M.exported ? from_moz_alias(M.exported) : new AST_String({\n                    start: start,\n                    value: \"*\",\n                    end: end,\n                }) ],\n                keys: [ new AST_String({\n                    start: start,\n                    value: \"*\",\n                    end: end,\n                }) ],\n                path: from_moz(M.source),\n            });\n        },\n        ExportDefaultDeclaration: function(M) {\n            var decl = from_moz(M.declaration);\n            if (!decl.name) switch (decl.CTOR) {\n              case AST_AsyncDefun:\n                decl = new AST_AsyncFunction(decl);\n                break;\n              case AST_AsyncGeneratorDefun:\n                decl = new AST_AsyncGeneratorFunction(decl);\n                break;\n              case AST_DefClass:\n                decl = new AST_ClassExpression(decl);\n                break;\n              case AST_Defun:\n                decl = new AST_Function(decl);\n                break;\n              case AST_GeneratorDefun:\n                decl = new AST_GeneratorFunction(decl);\n                break;\n            }\n            return new AST_ExportDefault({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                body: decl,\n            });\n        },\n        ExportNamedDeclaration: function(M) {\n            if (M.declaration) return new AST_ExportDeclaration({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                body: from_moz(M.declaration),\n            });\n            if (M.source) {\n                var aliases = [], keys = [];\n                M.specifiers.forEach(function(prop) {\n                    aliases.push(from_moz_alias(prop.exported));\n                    keys.push(from_moz_alias(prop.local));\n                });\n                return new AST_ExportForeign({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    aliases: aliases,\n                    keys: keys,\n                    path: from_moz(M.source),\n                });\n            }\n            return new AST_ExportReferences({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                properties: M.specifiers.map(function(prop) {\n                    var sym = new AST_SymbolExport(from_moz(prop.local));\n                    sym.alias = from_moz_alias(prop.exported);\n                    return sym;\n                }),\n            });\n        },\n        ImportDeclaration: function(M) {\n            var start = my_start_token(M);\n            var end = my_end_token(M);\n            var all = null, def = null, props = null;\n            M.specifiers.forEach(function(prop) {\n                var sym = new AST_SymbolImport(from_moz(prop.local));\n                switch (prop.type) {\n                  case \"ImportDefaultSpecifier\":\n                    def = sym;\n                    def.key = new AST_String({\n                        start: start,\n                        value: \"\",\n                        end: end,\n                    });\n                    break;\n                  case \"ImportNamespaceSpecifier\":\n                    all = sym;\n                    all.key = new AST_String({\n                        start: start,\n                        value: \"*\",\n                        end: end,\n                    });\n                    break;\n                  default:\n                    sym.key = from_moz_alias(prop.imported);\n                    if (!props) props = [];\n                    props.push(sym);\n                    break;\n                }\n            });\n            return new AST_Import({\n                start: start,\n                end: end,\n                all: all,\n                default: def,\n                properties: props,\n                path: from_moz(M.source),\n            });\n        },\n        ImportExpression: function(M) {\n            var start = my_start_token(M);\n            var arg = from_moz(M.source);\n            return new AST_Call({\n                start: start,\n                end: my_end_token(M),\n                expression: new AST_SymbolRef({\n                    start: start,\n                    end: arg.start,\n                    name: \"import\",\n                }),\n                args: [ arg ],\n            });\n        },\n        VariableDeclaration: function(M) {\n            return new ({\n                const: AST_Const,\n                let: AST_Let,\n            }[M.kind] || AST_Var)({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                definitions: M.declarations.map(from_moz),\n            });\n        },\n        Literal: function(M) {\n            var args = {\n                start: my_start_token(M),\n                end: my_end_token(M),\n            };\n            if (M.bigint) {\n                args.value = M.bigint.toLowerCase() + \"n\";\n                return new AST_BigInt(args);\n            }\n            var val = M.value;\n            if (val === null) return new AST_Null(args);\n            var rx = M.regex;\n            if (rx && rx.pattern) {\n                // RegExpLiteral as per ESTree AST spec\n                args.value = new RegExp(rx.pattern, rx.flags);\n                args.value.raw_source = rx.pattern;\n                return new AST_RegExp(args);\n            } else if (rx) {\n                // support legacy RegExp\n                args.value = M.regex && M.raw ? M.raw : val;\n                return new AST_RegExp(args);\n            }\n            switch (typeof val) {\n              case \"string\":\n                args.value = val;\n                return new AST_String(args);\n              case \"number\":\n                if (isNaN(val)) return new AST_NaN(args);\n                var negate, node;\n                if (isFinite(val)) {\n                    negate = 1 / val < 0;\n                    args.value = negate ? -val : val;\n                    node = new AST_Number(args);\n                } else {\n                    negate = val < 0;\n                    node = new AST_Infinity(args);\n                }\n                return negate ? new AST_UnaryPrefix({\n                    start: args.start,\n                    end: args.end,\n                    operator: \"-\",\n                    expression: node,\n                }) : node;\n              case \"boolean\":\n                return new (val ? AST_True : AST_False)(args);\n            }\n        },\n        TemplateLiteral: function(M) {\n            return new AST_Template({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                expressions: M.expressions.map(from_moz),\n                strings: M.quasis.map(function(el) {\n                    return el.value.raw;\n                }),\n            });\n        },\n        TaggedTemplateExpression: function(M) {\n            var tmpl = from_moz(M.quasi);\n            tmpl.start = my_start_token(M);\n            tmpl.end = my_end_token(M);\n            tmpl.tag = from_moz(M.tag);\n            return tmpl;\n        },\n        Identifier: function(M) {\n            var p, level = FROM_MOZ_STACK.length - 1;\n            do {\n                p = FROM_MOZ_STACK[--level];\n            } while (p.type == \"ArrayPattern\"\n                || p.type == \"AssignmentPattern\" && p.left === FROM_MOZ_STACK[level + 1]\n                || p.type == \"ObjectPattern\"\n                || p.type == \"Property\" && p.value === FROM_MOZ_STACK[level + 1]\n                || p.type == \"VariableDeclarator\" && p.id === FROM_MOZ_STACK[level + 1]);\n            var ctor = AST_SymbolRef;\n            switch (p.type) {\n              case \"ArrowFunctionExpression\":\n                if (p.body !== FROM_MOZ_STACK[level + 1]) ctor = AST_SymbolFunarg;\n                break;\n              case \"BreakStatement\":\n              case \"ContinueStatement\":\n                ctor = AST_LabelRef;\n                break;\n              case \"CatchClause\":\n                ctor = AST_SymbolCatch;\n                break;\n              case \"ClassDeclaration\":\n                if (p.id === FROM_MOZ_STACK[level + 1]) ctor = AST_SymbolDefClass;\n                break;\n              case \"ClassExpression\":\n                if (p.id === FROM_MOZ_STACK[level + 1]) ctor = AST_SymbolClass;\n                break;\n              case \"FunctionDeclaration\":\n                ctor = p.id === FROM_MOZ_STACK[level + 1] ? AST_SymbolDefun : AST_SymbolFunarg;\n                break;\n              case \"FunctionExpression\":\n                ctor = p.id === FROM_MOZ_STACK[level + 1] ? AST_SymbolLambda : AST_SymbolFunarg;\n                break;\n              case \"LabeledStatement\":\n                ctor = AST_Label;\n                break;\n              case \"VariableDeclaration\":\n                ctor = {\n                    const: AST_SymbolConst,\n                    let: AST_SymbolLet,\n                }[p.kind] || AST_SymbolVar;\n                break;\n            }\n            return new ctor({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                name: M.name,\n            });\n        },\n        Super: function(M) {\n            return new AST_Super({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                name: \"super\",\n            });\n        },\n        ThisExpression: function(M) {\n            return new AST_This({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                name: \"this\",\n            });\n        },\n        ParenthesizedExpression: function(M) {\n            var node = from_moz(M.expression);\n            if (!node.start.parens) node.start.parens = [];\n            node.start.parens.push(my_start_token(M));\n            if (!node.end.parens) node.end.parens = [];\n            node.end.parens.push(my_end_token(M));\n            return node;\n        },\n        ChainExpression: function(M) {\n            var node = from_moz(M.expression);\n            node.terminal = true;\n            return node;\n        },\n    };\n\n    MOZ_TO_ME.UpdateExpression =\n    MOZ_TO_ME.UnaryExpression = function To_Moz_Unary(M) {\n        var prefix = \"prefix\" in M ? M.prefix\n            : M.type == \"UnaryExpression\" ? true : false;\n        return new (prefix ? AST_UnaryPrefix : AST_UnaryPostfix)({\n            start      : my_start_token(M),\n            end        : my_end_token(M),\n            operator   : M.operator,\n            expression : from_moz(M.argument)\n        });\n    };\n\n    map(\"EmptyStatement\", AST_EmptyStatement);\n    map(\"ExpressionStatement\", AST_SimpleStatement, \"expression>body\");\n    map(\"BlockStatement\", AST_BlockStatement, \"body@body\");\n    map(\"IfStatement\", AST_If, \"test>condition, consequent>body, alternate>alternative\");\n    map(\"LabeledStatement\", AST_LabeledStatement, \"label>label, body>body\");\n    map(\"BreakStatement\", AST_Break, \"label>label\");\n    map(\"ContinueStatement\", AST_Continue, \"label>label\");\n    map(\"WithStatement\", AST_With, \"object>expression, body>body\");\n    map(\"SwitchStatement\", AST_Switch, \"discriminant>expression, cases@body\");\n    map(\"ReturnStatement\", AST_Return, \"argument>value\");\n    map(\"ThrowStatement\", AST_Throw, \"argument>value\");\n    map(\"WhileStatement\", AST_While, \"test>condition, body>body\");\n    map(\"DoWhileStatement\", AST_Do, \"test>condition, body>body\");\n    map(\"ForStatement\", AST_For, \"init>init, test>condition, update>step, body>body\");\n    map(\"ForInStatement\", AST_ForIn, \"left>init, right>object, body>body\");\n    map(\"DebuggerStatement\", AST_Debugger);\n    map(\"VariableDeclarator\", AST_VarDef, \"id>name, init>value\");\n    map(\"CatchClause\", AST_Catch, \"param>argname, body%body\");\n\n    map(\"BinaryExpression\", AST_Binary, \"operator=operator, left>left, right>right\");\n    map(\"LogicalExpression\", AST_Binary, \"operator=operator, left>left, right>right\");\n    map(\"AssignmentExpression\", AST_Assign, \"operator=operator, left>left, right>right\");\n    map(\"AssignmentPattern\", AST_DefaultValue, \"left>name, right>value\");\n    map(\"ConditionalExpression\", AST_Conditional, \"test>condition, consequent>consequent, alternate>alternative\");\n    map(\"NewExpression\", AST_New, \"callee>expression, arguments@args, pure=pure\");\n    map(\"CallExpression\", AST_Call, \"callee>expression, arguments@args, optional=optional, pure=pure\");\n    map(\"SequenceExpression\", AST_Sequence, \"expressions@expressions\");\n    map(\"SpreadElement\", AST_Spread, \"argument>expression\");\n    map(\"ObjectExpression\", AST_Object, \"properties@properties\");\n    map(\"AwaitExpression\", AST_Await, \"argument>expression\");\n    map(\"YieldExpression\", AST_Yield, \"argument>expression, delegate=nested\");\n\n    def_to_moz(AST_Toplevel, function To_Moz_Program(M) {\n        return to_moz_scope(\"Program\", M);\n    });\n\n    def_to_moz(AST_LambdaDefinition, function To_Moz_FunctionDeclaration(M) {\n        var params = M.argnames.map(to_moz);\n        if (M.rest) params.push({\n            type: \"RestElement\",\n            argument: to_moz(M.rest),\n        });\n        return {\n            type: \"FunctionDeclaration\",\n            id: to_moz(M.name),\n            async: is_async(M),\n            generator: is_generator(M),\n            params: params,\n            body: to_moz_scope(\"BlockStatement\", M),\n        };\n    });\n\n    def_to_moz(AST_Lambda, function To_Moz_FunctionExpression(M) {\n        var params = M.argnames.map(to_moz);\n        if (M.rest) params.push({\n            type: \"RestElement\",\n            argument: to_moz(M.rest),\n        });\n        if (is_arrow(M)) return {\n            type: \"ArrowFunctionExpression\",\n            async: is_async(M),\n            params: params,\n            body: M.value ? to_moz(M.value) : to_moz_scope(\"BlockStatement\", M),\n        };\n        return {\n            type: \"FunctionExpression\",\n            id: to_moz(M.name),\n            async: is_async(M),\n            generator: is_generator(M),\n            params: params,\n            body: to_moz_scope(\"BlockStatement\", M),\n        };\n    });\n\n    def_to_moz(AST_DefClass, function To_Moz_ClassDeclaration(M) {\n        return {\n            type: \"ClassDeclaration\",\n            id: to_moz(M.name),\n            superClass: to_moz(M.extends),\n            body: {\n                type: \"ClassBody\",\n                body: M.properties.map(to_moz),\n            },\n        };\n    });\n\n    def_to_moz(AST_ClassExpression, function To_Moz_ClassExpression(M) {\n        return {\n            type: \"ClassExpression\",\n            id: to_moz(M.name),\n            superClass: to_moz(M.extends),\n            body: {\n                type: \"ClassBody\",\n                body: M.properties.map(to_moz),\n            },\n        };\n    });\n\n    function To_Moz_MethodDefinition(kind) {\n        return function(M) {\n            var computed = M.key instanceof AST_Node;\n            var key = computed ? to_moz(M.key) : M.private ? {\n                type: \"PrivateIdentifier\",\n                name: M.key.slice(1),\n            } : {\n                type: \"Literal\",\n                value: M.key,\n            };\n            return {\n                type: \"MethodDefinition\",\n                kind: kind,\n                computed: computed,\n                key: key,\n                static: M.static,\n                value: to_moz(M.value),\n            };\n        };\n    }\n    def_to_moz(AST_ClassGetter, To_Moz_MethodDefinition(\"get\"));\n    def_to_moz(AST_ClassSetter, To_Moz_MethodDefinition(\"set\"));\n    def_to_moz(AST_ClassMethod, To_Moz_MethodDefinition(\"method\"));\n\n    def_to_moz(AST_ClassField, function To_Moz_PropertyDefinition(M) {\n        var computed = M.key instanceof AST_Node;\n        var key = computed ? to_moz(M.key) : M.private ? {\n            type: \"PrivateIdentifier\",\n            name: M.key.slice(1),\n        } : {\n            type: \"Literal\",\n            value: M.key,\n        };\n        return {\n            type: \"PropertyDefinition\",\n            computed: computed,\n            key: key,\n            static: M.static,\n            value: to_moz(M.value),\n        };\n    });\n\n    def_to_moz(AST_ClassInit, function To_Moz_StaticBlock(M) {\n        return to_moz_scope(\"StaticBlock\", M.value);\n    });\n\n    function To_Moz_ForOfStatement(is_await) {\n        return function(M) {\n            return {\n                type: \"ForOfStatement\",\n                await: is_await,\n                left: to_moz(M.init),\n                right: to_moz(M.object),\n                body: to_moz(M.body),\n            };\n        };\n    }\n    def_to_moz(AST_ForAwaitOf, To_Moz_ForOfStatement(true));\n    def_to_moz(AST_ForOf, To_Moz_ForOfStatement(false));\n\n    def_to_moz(AST_Directive, function To_Moz_Directive(M) {\n        return {\n            type: \"ExpressionStatement\",\n            expression: set_moz_loc(M, {\n                type: \"Literal\",\n                value: M.value,\n            }),\n        };\n    });\n\n    def_to_moz(AST_SwitchBranch, function To_Moz_SwitchCase(M) {\n        return {\n            type: \"SwitchCase\",\n            test: to_moz(M.expression),\n            consequent: M.body.map(to_moz),\n        };\n    });\n\n    def_to_moz(AST_Try, function To_Moz_TryStatement(M) {\n        return {\n            type: \"TryStatement\",\n            block: to_moz_block(M),\n            handler: to_moz(M.bcatch),\n            guardedHandlers: [],\n            finalizer: to_moz(M.bfinally),\n        };\n    });\n\n    def_to_moz(AST_Catch, function To_Moz_CatchClause(M) {\n        return {\n            type: \"CatchClause\",\n            param: to_moz(M.argname),\n            guard: null,\n            body: to_moz_block(M),\n        };\n    });\n\n    def_to_moz(AST_ExportDeclaration, function To_Moz_ExportNamedDeclaration_declaration(M) {\n        return {\n            type: \"ExportNamedDeclaration\",\n            declaration: to_moz(M.body),\n        };\n    });\n\n    def_to_moz(AST_ExportDefault, function To_Moz_ExportDefaultDeclaration(M) {\n        return {\n            type: \"ExportDefaultDeclaration\",\n            declaration: to_moz(M.body),\n        };\n    });\n\n    def_to_moz(AST_ExportForeign, function To_Moz_ExportAllDeclaration_ExportNamedDeclaration(M) {\n        if (M.keys[0].value == \"*\") return {\n            type: \"ExportAllDeclaration\",\n            exported: M.aliases[0].value == \"*\" ? null : to_moz_alias(M.aliases[0]),\n            source: to_moz(M.path),\n        };\n        var specifiers = [];\n        for (var i = 0; i < M.aliases.length; i++) {\n            specifiers.push(set_moz_loc({\n                start: M.keys[i].start,\n                end: M.aliases[i].end,\n            }, {\n                type: \"ExportSpecifier\",\n                local: to_moz_alias(M.keys[i]),\n                exported: to_moz_alias(M.aliases[i]),\n            }));\n        }\n        return {\n            type: \"ExportNamedDeclaration\",\n            specifiers: specifiers,\n            source: to_moz(M.path),\n        };\n    });\n\n    def_to_moz(AST_ExportReferences, function To_Moz_ExportNamedDeclaration_specifiers(M) {\n        return {\n            type: \"ExportNamedDeclaration\",\n            specifiers: M.properties.map(function(prop) {\n                return set_moz_loc({\n                    start: prop.start,\n                    end: prop.alias.end,\n                }, {\n                    type: \"ExportSpecifier\",\n                    local: to_moz(prop),\n                    exported: to_moz_alias(prop.alias),\n                });\n            }),\n        };\n    });\n\n    def_to_moz(AST_Import, function To_Moz_ImportDeclaration(M) {\n        var specifiers = M.properties ? M.properties.map(function(prop) {\n            return set_moz_loc({\n                start: prop.key.start,\n                end: prop.end,\n            }, {\n                type: \"ImportSpecifier\",\n                local: to_moz(prop),\n                imported: to_moz_alias(prop.key),\n            });\n        }) : [];\n        if (M.all) specifiers.unshift(set_moz_loc(M.all, {\n            type: \"ImportNamespaceSpecifier\",\n            local: to_moz(M.all),\n        }));\n        if (M.default) specifiers.unshift(set_moz_loc(M.default, {\n            type: \"ImportDefaultSpecifier\",\n            local: to_moz(M.default),\n        }));\n        return {\n            type: \"ImportDeclaration\",\n            specifiers: specifiers,\n            source: to_moz(M.path),\n        };\n    });\n\n    def_to_moz(AST_Definitions, function To_Moz_VariableDeclaration(M) {\n        return {\n            type: \"VariableDeclaration\",\n            kind: M.TYPE.toLowerCase(),\n            declarations: M.definitions.map(to_moz),\n        };\n    });\n\n    def_to_moz(AST_PropAccess, function To_Moz_MemberExpression(M) {\n        var computed = M instanceof AST_Sub;\n        var expr = {\n            type: \"MemberExpression\",\n            object: to_moz(M.expression),\n            computed: computed,\n            optional: M.optional,\n            property: computed ? to_moz(M.property) : {\n                type: \"Identifier\",\n                name: M.property,\n            },\n        };\n        return M.terminal ? {\n            type: \"ChainExpression\",\n            expression: expr,\n        } : expr;\n    });\n\n    def_to_moz(AST_Unary, function To_Moz_Unary(M) {\n        return {\n            type: M.operator == \"++\" || M.operator == \"--\" ? \"UpdateExpression\" : \"UnaryExpression\",\n            operator: M.operator,\n            prefix: M instanceof AST_UnaryPrefix,\n            argument: to_moz(M.expression)\n        };\n    });\n\n    def_to_moz(AST_Binary, function To_Moz_BinaryExpression(M) {\n        return {\n            type: M.operator == \"&&\" || M.operator == \"||\" ? \"LogicalExpression\" : \"BinaryExpression\",\n            left: to_moz(M.left),\n            operator: M.operator,\n            right: to_moz(M.right)\n        };\n    });\n\n    def_to_moz(AST_Array, function To_Moz_ArrayExpression(M) {\n        return {\n            type: \"ArrayExpression\",\n            elements: M.elements.map(to_moz),\n        };\n    });\n\n    def_to_moz(AST_DestructuredArray, function To_Moz_ArrayPattern(M) {\n        var elements = M.elements.map(to_moz);\n        if (M.rest) elements.push({\n            type: \"RestElement\",\n            argument: to_moz(M.rest),\n        });\n        return {\n            type: \"ArrayPattern\",\n            elements: elements,\n        };\n    });\n\n    def_to_moz(AST_DestructuredKeyVal, function To_Moz_Property(M) {\n        var computed = M.key instanceof AST_Node;\n        var key = computed ? to_moz(M.key) : {\n            type: \"Literal\",\n            value: M.key,\n        };\n        return {\n            type: \"Property\",\n            kind: \"init\",\n            computed: computed,\n            key: key,\n            value: to_moz(M.value),\n        };\n    });\n\n    def_to_moz(AST_DestructuredObject, function To_Moz_ObjectPattern(M) {\n        var props = M.properties.map(to_moz);\n        if (M.rest) props.push({\n            type: \"RestElement\",\n            argument: to_moz(M.rest),\n        });\n        return {\n            type: \"ObjectPattern\",\n            properties: props,\n        };\n    });\n\n    def_to_moz(AST_ObjectProperty, function To_Moz_Property(M) {\n        var computed = M.key instanceof AST_Node;\n        var key = computed ? to_moz(M.key) : {\n            type: \"Literal\",\n            value: M.key,\n        };\n        var kind;\n        if (M instanceof AST_ObjectKeyVal) {\n            kind = \"init\";\n        } else if (M instanceof AST_ObjectGetter) {\n            kind = \"get\";\n        } else if (M instanceof AST_ObjectSetter) {\n            kind = \"set\";\n        }\n        return {\n            type: \"Property\",\n            kind: kind,\n            computed: computed,\n            method: M instanceof AST_ObjectMethod,\n            key: key,\n            value: to_moz(M.value),\n        };\n    });\n\n    def_to_moz(AST_Symbol, function To_Moz_Identifier(M) {\n        var def = M.definition();\n        return {\n            type: \"Identifier\",\n            name: def && def.mangled_name || M.name,\n        };\n    });\n\n    def_to_moz(AST_Super, function To_Moz_Super() {\n        return { type: \"Super\" };\n    });\n\n    def_to_moz(AST_This, function To_Moz_ThisExpression() {\n        return { type: \"ThisExpression\" };\n    });\n\n    def_to_moz(AST_NewTarget, function To_Moz_MetaProperty() {\n        return {\n            type: \"MetaProperty\",\n            meta: {\n                type: \"Identifier\",\n                name: \"new\",\n            },\n            property: {\n                type: \"Identifier\",\n                name: \"target\",\n            },\n        };\n    });\n\n    def_to_moz(AST_RegExp, function To_Moz_RegExpLiteral(M) {\n        var flags = M.value.toString().match(/\\/([gimuy]*)$/)[1];\n        var value = \"/\" + M.value.raw_source + \"/\" + flags;\n        return {\n            type: \"Literal\",\n            value: value,\n            raw: value,\n            regex: {\n                pattern: M.value.raw_source,\n                flags: flags,\n            },\n        };\n    });\n\n    def_to_moz(AST_BigInt, function To_Moz_BigInt(M) {\n        var value = M.value;\n        return {\n            type: \"Literal\",\n            bigint: value.slice(0, -1),\n            raw: value,\n        };\n    });\n\n    function To_Moz_Literal(M) {\n        var value = M.value;\n        if (typeof value === \"number\" && (value < 0 || (value === 0 && 1 / value < 0))) {\n            return {\n                type: \"UnaryExpression\",\n                operator: \"-\",\n                prefix: true,\n                argument: {\n                    type: \"Literal\",\n                    value: -value,\n                    raw: M.start.raw,\n                },\n            };\n        }\n        return {\n            type: \"Literal\",\n            value: value,\n            raw: M.start.raw,\n        };\n    }\n    def_to_moz(AST_Boolean, To_Moz_Literal);\n    def_to_moz(AST_Constant, To_Moz_Literal);\n    def_to_moz(AST_Null, To_Moz_Literal);\n\n    def_to_moz(AST_Atom, function To_Moz_Atom(M) {\n        return {\n            type: \"Identifier\",\n            name: String(M.value),\n        };\n    });\n\n    def_to_moz(AST_Template, function To_Moz_TemplateLiteral_TaggedTemplateExpression(M) {\n        var last = M.strings.length - 1;\n        var tmpl = {\n            type: \"TemplateLiteral\",\n            expressions: M.expressions.map(to_moz),\n            quasis: M.strings.map(function(str, index) {\n                return {\n                    type: \"TemplateElement\",\n                    tail: index == last,\n                    value: { raw: str },\n                };\n            }),\n        };\n        if (!M.tag) return tmpl;\n        return {\n            type: \"TaggedTemplateExpression\",\n            tag: to_moz(M.tag),\n            quasi: tmpl,\n        };\n    });\n\n    AST_Block.DEFMETHOD(\"to_mozilla_ast\", AST_BlockStatement.prototype.to_mozilla_ast);\n    AST_Hole.DEFMETHOD(\"to_mozilla_ast\", return_null);\n    AST_Node.DEFMETHOD(\"to_mozilla_ast\", function() {\n        throw new Error(\"Cannot convert AST_\" + this.TYPE);\n    });\n\n    /* -----[ tools ]----- */\n\n    function normalize_directives(body) {\n        for (var i = 0; i < body.length; i++) {\n            var stat = body[i];\n            if (!(stat instanceof AST_SimpleStatement)) break;\n            var node = stat.body;\n            if (!(node instanceof AST_String)) break;\n            if (stat.start.pos !== node.start.pos) break;\n            body[i] = new AST_Directive(node);\n        }\n        return body;\n    }\n\n    function raw_token(moznode) {\n        if (moznode.type == \"Literal\") {\n            return moznode.raw != null ? moznode.raw : moznode.value + \"\";\n        }\n    }\n\n    function my_start_token(moznode) {\n        var loc = moznode.loc, start = loc && loc.start;\n        var range = moznode.range;\n        return new AST_Token({\n            file    : loc && loc.source,\n            line    : start && start.line,\n            col     : start && start.column,\n            pos     : range ? range[0] : moznode.start,\n            endline : start && start.line,\n            endcol  : start && start.column,\n            endpos  : range ? range[0] : moznode.start,\n            raw     : raw_token(moznode),\n        });\n    }\n\n    function my_end_token(moznode) {\n        var loc = moznode.loc, end = loc && loc.end;\n        var range = moznode.range;\n        return new AST_Token({\n            file    : loc && loc.source,\n            line    : end && end.line,\n            col     : end && end.column,\n            pos     : range ? range[1] : moznode.end,\n            endline : end && end.line,\n            endcol  : end && end.column,\n            endpos  : range ? range[1] : moznode.end,\n            raw     : raw_token(moznode),\n        });\n    }\n\n    function read_name(M) {\n        return \"\" + M[M.type == \"Identifier\" ? \"name\" : \"value\"];\n    }\n\n    function map(moztype, mytype, propmap) {\n        var moz_to_me = [\n            \"start: my_start_token(M)\",\n            \"end: my_end_token(M)\",\n        ];\n        var me_to_moz = [\n            \"type: \" + JSON.stringify(moztype),\n        ];\n\n        if (propmap) propmap.split(/\\s*,\\s*/).forEach(function(prop) {\n            var m = /([a-z0-9$_]+)(=|@|>|%)([a-z0-9$_]+)/i.exec(prop);\n            if (!m) throw new Error(\"Can't understand property map: \" + prop);\n            var moz = m[1], how = m[2], my = m[3];\n            switch (how) {\n              case \"@\":\n                moz_to_me.push(my + \": M.\" + moz + \".map(from_moz)\");\n                me_to_moz.push(moz + \": M.\" +  my + \".map(to_moz)\");\n                break;\n              case \">\":\n                moz_to_me.push(my + \": from_moz(M.\" + moz + \")\");\n                me_to_moz.push(moz + \": to_moz(M.\" + my + \")\");\n                break;\n              case \"=\":\n                moz_to_me.push(my + \": M.\" + moz);\n                me_to_moz.push(moz + \": M.\" + my);\n                break;\n              case \"%\":\n                moz_to_me.push(my + \": from_moz(M.\" + moz + \").body\");\n                me_to_moz.push(moz + \": to_moz_block(M)\");\n                break;\n              default:\n                throw new Error(\"Can't understand operator in propmap: \" + prop);\n            }\n        });\n\n        MOZ_TO_ME[moztype] = new Function(\"U2\", \"my_start_token\", \"my_end_token\", \"from_moz\", [\n            \"return function From_Moz_\" + moztype + \"(M) {\",\n            \"    return new U2.AST_\" + mytype.TYPE + \"({\",\n            moz_to_me.join(\",\\n\"),\n            \"    });\",\n            \"};\",\n        ].join(\"\\n\"))(exports, my_start_token, my_end_token, from_moz);\n        def_to_moz(mytype, new Function(\"to_moz\", \"to_moz_block\", \"to_moz_scope\", [\n            \"return function To_Moz_\" + moztype + \"(M) {\",\n            \"    return {\",\n            me_to_moz.join(\",\\n\"),\n            \"    };\",\n            \"};\",\n        ].join(\"\\n\"))(to_moz, to_moz_block, to_moz_scope));\n    }\n\n    var FROM_MOZ_STACK = null;\n\n    function from_moz(moz) {\n        FROM_MOZ_STACK.push(moz);\n        var node = null;\n        if (moz) {\n            if (!HOP(MOZ_TO_ME, moz.type)) throw new Error(\"Unsupported type: \" + moz.type);\n            node = MOZ_TO_ME[moz.type](moz);\n        }\n        FROM_MOZ_STACK.pop();\n        return node;\n    }\n\n    function from_moz_alias(moz) {\n        return new AST_String({\n            start: my_start_token(moz),\n            value: read_name(moz),\n            end: my_end_token(moz),\n        });\n    }\n\n    AST_Node.from_mozilla_ast = function(node) {\n        var save_stack = FROM_MOZ_STACK;\n        FROM_MOZ_STACK = [];\n        var ast = from_moz(node);\n        FROM_MOZ_STACK = save_stack;\n        ast.walk(new TreeWalker(function(node) {\n            if (node instanceof AST_LabelRef) {\n                for (var level = 0, parent; parent = this.parent(level); level++) {\n                    if (parent instanceof AST_Scope) break;\n                    if (parent instanceof AST_LabeledStatement && parent.label.name == node.name) {\n                        node.thedef = parent.label;\n                        break;\n                    }\n                }\n                if (!node.thedef) {\n                    var s = node.start;\n                    js_error(\"Undefined label \" + node.name, s.file, s.line, s.col, s.pos);\n                }\n            }\n        }));\n        return ast;\n    };\n\n    function set_moz_loc(mynode, moznode) {\n        var start = mynode.start;\n        var end = mynode.end;\n        if (start.pos != null && end.endpos != null) {\n            moznode.range = [start.pos, end.endpos];\n        }\n        if (start.line) {\n            moznode.loc = {\n                start: {line: start.line, column: start.col},\n                end: end.endline ? {line: end.endline, column: end.endcol} : null,\n            };\n            if (start.file) {\n                moznode.loc.source = start.file;\n            }\n        }\n        return moznode;\n    }\n\n    function def_to_moz(mytype, handler) {\n        mytype.DEFMETHOD(\"to_mozilla_ast\", function() {\n            return set_moz_loc(this, handler(this));\n        });\n    }\n\n    function to_moz(node) {\n        return node != null ? node.to_mozilla_ast() : null;\n    }\n\n    function to_moz_alias(alias) {\n        return is_identifier_string(alias.value) ? set_moz_loc(alias, {\n            type: \"Identifier\",\n            name: alias.value,\n        }) : to_moz(alias);\n    }\n\n    function to_moz_block(node) {\n        return {\n            type: \"BlockStatement\",\n            body: node.body.map(to_moz),\n        };\n    }\n\n    function to_moz_scope(type, node) {\n        var body = node.body.map(to_moz);\n        if (node.body[0] instanceof AST_SimpleStatement && node.body[0].body instanceof AST_String) {\n            body.unshift(to_moz(new AST_EmptyStatement(node.body[0])));\n        }\n        return {\n            type: type,\n            body: body,\n        };\n    }\n})();\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}